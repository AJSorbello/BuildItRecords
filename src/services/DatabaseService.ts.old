import { collection, getDocs, query, where, addDoc, updateDoc, doc, deleteDoc } from 'firebase/firestore';
import { db } from '../config/firebase';
import { Artist } from '../types/Artist';
import { Track } from '../types/track';
import { RECORD_LABELS, RecordLabel } from '../constants/labels';

export class DatabaseService {
  private static instance: DatabaseService | null = null;

  private constructor() {}

  public static getInstance(): DatabaseService {
    if (!DatabaseService.instance) {
      DatabaseService.instance = new DatabaseService();
    }
    return DatabaseService.instance;
  }

  public async getTracks(): Promise<Track[]> {
    try {
      const tracksRef = collection(db, 'tracks');
      const snapshot = await getDocs(tracksRef);
      return snapshot.docs.map(doc => {
        const data = doc.data();
        return {
          id: doc.id,
          title: data.title || '',
          artist: {
            name: data.artistName || '',
            spotifyUrl: data.artistSpotifyUrl || '',
          },
          imageUrl: data.imageUrl || '',
          releaseDate: data.releaseDate || '',
          genre: data.genre || '',
          labelName: data.labelName as RecordLabel || RECORD_LABELS['Build It Records'],
          label: data.label as RecordLabel || RECORD_LABELS['Build It Records'],
          stores: {
            spotify: data.spotifyUrl || '',
            beatport: data.beatportUrl || '',
            soundcloud: data.soundcloudUrl || '',
          },
          spotifyUrl: data.spotifyUrl || '',
        };
      });
    } catch (error) {
      console.error('Error getting tracks:', error);
      throw error;
    }
  }

  public async getTracksByLabel(label: RecordLabel): Promise<Track[]> {
    try {
      const tracksRef = collection(db, 'tracks');
      const q = query(tracksRef, where('label', '==', label));
      const snapshot = await getDocs(q);
      
      return snapshot.docs.map(doc => {
        const data = doc.data();
        return {
          id: doc.id,
          title: data.title || '',
          artist: {
            name: data.artistName || '',
            spotifyUrl: data.artistSpotifyUrl || '',
          },
          imageUrl: data.imageUrl || '',
          releaseDate: data.releaseDate || '',
          genre: data.genre || '',
          labelName: data.labelName as RecordLabel || label,
          label: data.label as RecordLabel || label,
          stores: {
            spotify: data.spotifyUrl || '',
            beatport: data.beatportUrl || '',
            soundcloud: data.soundcloudUrl || '',
          },
          spotifyUrl: data.spotifyUrl || '',
        };
      });
    } catch (error) {
      console.error('Error getting tracks by label:', error);
      throw error;
    }
  }

  public async addTrack(track: Track): Promise<string> {
    try {
      const tracksRef = collection(db, 'tracks');
      const docRef = await addDoc(tracksRef, {
        title: track.title,
        artistName: track.artist.name,
        artistSpotifyUrl: track.artist.spotifyUrl,
        imageUrl: track.imageUrl,
        releaseDate: track.releaseDate,
        genre: track.genre,
        labelName: track.labelName,
        label: track.label,
        spotifyUrl: track.stores.spotify,
        beatportUrl: track.stores.beatport,
        soundcloudUrl: track.stores.soundcloud,
      });
      return docRef.id;
    } catch (error) {
      console.error('Error adding track:', error);
      throw error;
    }
  }

  public async updateTrack(id: string, track: Partial<Track>): Promise<void> {
    try {
      const trackRef = doc(db, 'tracks', id);
      const updateData: any = {};

      if (track.title) updateData.title = track.title;
      if (track.artist) {
        updateData.artistName = track.artist.name;
        updateData.artistSpotifyUrl = track.artist.spotifyUrl;
      }
      if (track.imageUrl) updateData.imageUrl = track.imageUrl;
      if (track.releaseDate) updateData.releaseDate = track.releaseDate;
      if (track.genre) updateData.genre = track.genre;
      if (track.labelName) updateData.labelName = track.labelName;
      if (track.label) updateData.label = track.label;
      if (track.stores) {
        if (track.stores.spotify) updateData.spotifyUrl = track.stores.spotify;
        if (track.stores.beatport) updateData.beatportUrl = track.stores.beatport;
        if (track.stores.soundcloud) updateData.soundcloudUrl = track.stores.soundcloud;
      }

      await updateDoc(trackRef, updateData);
    } catch (error) {
      console.error('Error updating track:', error);
      throw error;
    }
  }

  public async deleteTrack(id: string): Promise<void> {
    try {
      const trackRef = doc(db, 'tracks', id);
      await deleteDoc(trackRef);
    } catch (error) {
      console.error('Error deleting track:', error);
      throw error;
    }
  }

  public async getArtists(): Promise<Artist[]> {
    try {
      const artistsRef = collection(db, 'artists');
      const snapshot = await getDocs(artistsRef);
      return snapshot.docs.map(doc => {
        const data = doc.data();
        return {
          id: doc.id,
          name: data.name || '',
          imageUrl: data.imageUrl || '',
          spotifyUrl: data.spotifyUrl || '',
          genres: data.genres || [],
          followers: {
            total: data.followers?.total || 0,
          },
          monthlyListeners: data.monthlyListeners || 0,
          recordLabel: data.recordLabel as RecordLabel || RECORD_LABELS['Build It Records'],
          labels: data.labels as RecordLabel[] || [RECORD_LABELS['Build It Records']],
          bio: data.bio || '',
        };
      });
    } catch (error) {
      console.error('Error getting artists:', error);
      throw error;
    }
  }

  public async addArtist(artist: Artist): Promise<string> {
    try {
      const artistsRef = collection(db, 'artists');
      const docRef = await addDoc(artistsRef, {
        name: artist.name,
        imageUrl: artist.imageUrl,
        spotifyUrl: artist.spotifyUrl,
        genres: artist.genres,
        followers: artist.followers,
        monthlyListeners: artist.monthlyListeners,
        recordLabel: artist.recordLabel,
        labels: artist.labels,
        bio: artist.bio,
      });
      return docRef.id;
    } catch (error) {
      console.error('Error adding artist:', error);
      throw error;
    }
  }

  public async updateArtist(id: string, artist: Partial<Artist>): Promise<void> {
    try {
      const artistRef = doc(db, 'artists', id);
      const updateData: any = {};

      if (artist.name) updateData.name = artist.name;
      if (artist.imageUrl) updateData.imageUrl = artist.imageUrl;
      if (artist.spotifyUrl) updateData.spotifyUrl = artist.spotifyUrl;
      if (artist.genres) updateData.genres = artist.genres;
      if (artist.followers) updateData.followers = artist.followers;
      if (artist.monthlyListeners) updateData.monthlyListeners = artist.monthlyListeners;
      if (artist.recordLabel) updateData.recordLabel = artist.recordLabel;
      if (artist.labels) updateData.labels = artist.labels;
      if (artist.bio) updateData.bio = artist.bio;

      await updateDoc(artistRef, updateData);
    } catch (error) {
      console.error('Error updating artist:', error);
      throw error;
    }
  }

  public async deleteArtist(id: string): Promise<void> {
    try {
      const artistRef = doc(db, 'artists', id);
      await deleteDoc(artistRef);
    } catch (error) {
      console.error('Error deleting artist:', error);
      throw error;
    }
  }
}

export const databaseService = DatabaseService.getInstance();
export default DatabaseService;
